#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :script.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.root_command
root_command() {
  inspect_args
}

# :command.version_command
version_command() {
  echo "$version"
}

detect_os() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    os="linux"
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    os="mac"
    if [[ `uname -m` == 'arm64' ]]; then
      arch="arm64"
    fi
  elif [[ "$OSTYPE" == "cygwin" ]]; then
    os="cygwin"
  elif [[ "$OSTYPE" == "msys" ]]; then
    os="msys"
  elif [[ "$OSTYPE" == "win32" ]]; then
    os="win"
  elif [[ "$OSTYPE" == "freebsd"* ]]; then
    os="freebsd"
  else
    os="unknown"
  fi
}

detect_distro() {
  if [ -f /etc/os-release ]; then
    # freedesktop.org and systemd
    . /etc/os-release
    DISTRO=$NAME
    VER=$VERSION_ID
  elif type lsb_release >/dev/null 2>&1; then
      # linuxbase.org
      DISTRO=$(lsb_release -si)
      VER=$(lsb_release -sr)
  elif [ -f /etc/lsb-release ]; then
      # For some versions of Debian/Ubuntu without lsb_release command
      . /etc/lsb-release
      DISTRO=$DISTRIB_ID
      VER=$DISTRIB_RELEASE
  elif [ -f /etc/debian_version ]; then
      # Older Debian/Ubuntu/etc.
      DISTRO=Debian
      VER=$(cat /etc/debian_version)
  elif [ -f /etc/SuSe-release ]; then
      # Older SuSE/etc.
      ...
  elif [ -f /etc/redhat-release ]; then
      # Older Red Hat, CentOS, etc.
      ...
  else
      # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
      DISTRO=$(uname -s)
      VER=$(uname -r)
  fi
}

dependencies_install() {
  packagesNeeded='git python3 python3-pip ntp ca-certificates curl gnupg make'

  if [[ "${os}" == 'linux' ]]; then
    if [ -x "$(command -v apk)" ];       then yes | sudo apk add --no-cache $packagesNeeded
    elif [ -x "$(command -v apt-get)" ]; then yes | sudo apt update && sudo apt-get install $packagesNeeded
    elif [ -x "$(command -v dnf)" ];     then yes | sudo dnf install $packagesNeeded
    elif [ -x "$(command -v zypper)" ];  then yes | sudo zypper install $packagesNeeded
    elif [ -x "$(command -v pacman)" ];  then yes | sudo pacman -Syy && sudo pacman -S $packagesNeeded
    elif [ -x "$(command -v yum)" ];     then yes | sudo yum install $packagesNeeded
    else echo -e "${RED}FAILED TO INSTALL PACKAGE: Package manager not found. You must manually install: $packagesNeeded ${NC}">&2; fi

    curl -fsSL https://get.docker.com -o get-docker.sh
    sudo sh get-docker.sh
    sudo usermod -aG docker $USER
    sudo systemctl enable docker
    sudo systemctl start docker
    sudo pip3 install docker-compose
  fi
}

install() {
  detect_os
  [[ "${os}" == 'linux' ]] && detect_distro

  RED='\033[0;31m'
  GREEN='\033[0;32m'
  PURPLE='\033[0;35m'
  NC='\033[0m' # No Color

  echo -e "${GREEN}Installation has started üöÄ ${NC} \n"
  read -n1 -p "Would you like to use the default ARTEMIS configs? (type 'y' or 'n'): "
  echo
  if [[ "${REPLY}" == 'n' ]]; then 
    read -n1 -p $'Would you like to edit the backend and monitor log configs? (type "y" or "n"): '
    [[ "${REPLY}" == 'y' ]] && vim local_configs/backend/logging.yaml && vim local_configs/monitor/logging.yaml
    echo

    read -n1 -p 'Would you like to modify the default database credentials? (type "y" or "n"): '
    if [[ "${REPLY}" == 'y' ]]; then 
      read -r -p $'\x0aInsert the new database username (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/^DB_USER=.*/DB_USER=${REPLY}/" .env
      read -r -p 'Insert the new database password (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/^DB_PASS=.*/DB_PASS=${REPLY}/" .env
    fi
    echo

    read -n1 -p 'Would you like to modify the default WEB application configuration? (type "y" or "n"): '
    if [[ "${REPLY}" == 'y' ]]; then
      read -r -p $'\x0aInsert the new MongoDB username (press ENTER for default): '  && [[ "${REPLY}" != '' ]] && sed -ie "s/MONGODB_USER=.*/MONGODB_USER=${REPLY}/" .env
      read -r -p 'Insert the new MongoDB password (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/MONGODB_PASS=.*/MONGODB_PASS=${REPLY}/" .env

      read -r -p 'Insert the new admin username (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/ADMIN_EMAIL=.*/ADMIN_EMAIL=${REPLY}/" .env
      read -r -p 'Insert the new admin password (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/ADMIN_PASS=.*/ADMIN_PASS=${REPLY}/" .env

      read -r -p 'Insert the session cookie timeout (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/SESSION_TIMEOUT=.*/SESSION_TIMEOUT=${REPLY}/" .env
      read -r -p 'Insert the session inactivity timeout (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/INACTIVITY_TIMEOUT=.*/INACTIVITY_TIMEOUT=${REPLY}/" .env

      read -r -p 'Insert the API rate-limiting time window (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LIMIT_WINDOW=.*/LIMIT_WINDOW=${REPLY}/" .env
      read -r -p 'Insert the API rate-limiting number of allowed requests (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LIMIT_REQUESTS=.*/LIMIT_REQUESTS=${REPLY}/" .env

      read -r -p 'Insert the ARTEMIS web base directory (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/ARTEMIS_WEB_BASE_DIR=.*/ARTEMIS_WEB_BASE_DIR=${REPLY}/" .env

      read -p 'What is this instance WEB host (e.g. artemis.com)? ' && sed -ie "s/ARTEMIS_WEB_HOST=.*/ARTEMIS_WEB_HOST=${REPLY}/" .env

      read -n1 -p 'Will you be using LDAP ? (type "y" or "n"): '
      if [[ "${REPLY}" == 'y' ]]; then
        read -r -p 'Insert the LDAP server URL (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_URL=.*/LDAP_SERVER_URL=${REPLY}/" .env
        read -r -p 'Insert the LDAP server port (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_PORT=.*/LDAP_SERVER_PORT=${REPLY}/" .env
        read -r -p 'Insert the LDAP server bind DN (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_BIND_DN=.*/LDAP_SERVER_BIND_DN=${REPLY}/" .env
        read -r -p 'Insert the LDAP server bind password (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_BIND_PASS=.*/LDAP_SERVER_BIND_PASS=${REPLY}/" .env
        read -r -p 'Insert the LDAP server search base (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_SEARCH_BASE=.*/LDAP_SERVER_SEARCH_BASE=${REPLY}/" .env
        read -r -p 'Insert the LDAP server search filter (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_SEARCH_FILTER=.*/LDAP_SERVER_SEARCH_FILTER=${REPLY}/" .env
        read -r -p 'Insert the LDAP server search filter attribute (press ENTER for default): ' && [[ "${REPLY}" != '' ]] && sed -ie "s/LDAP_SERVER_SEARCH_FILTER_ATTRIBUTE=.*/LDAP_SERVER_SEARCH_FILTER" .env
      else
        sed -ie "s/LDAP_ENABLED=.*/LDAP_ENABLED=false/" .env
      fi
    fi

    echo -e "\n${PURPLE}Lets change the secret keys üîí ${NC} \n"
    read -r -p 'Insert the master password for Hasura : ' && sed -ie "s/HASURA_SECRET_KEY=.*/HASURA_SECRET_KEY=${REPLY}/" .env
    read -r -p 'Insert the JWT secret key : ' && sed -ie "s/JWT_SECRET_KEY=.*/JWT_SECRET_KEY=${REPLY}/" .env
    read -r -p 'Insert the CSRF protection secret : ' && sed -ie "s/CSRF_SECRET=.*/CSRF_SECRET=${REPLY}/" .env
    read -r -p 'Insert the API client key : ' && sed -ie "s/API_KEY=.*/API_KEY=${REPLY}/" .env
    read -r -p 'Insert the CAPTCHA protection secret : ' && sed -ie "s/CAPTCHA_SECRET=.*/CAPTCHA_SECRET=${REPLY}/" .env

    echo -e "\n${GREEN}All the necessary configuration ‚öôÔ∏è is created${NC} \n"
  else
    echo -e "\n${GREEN}Installation procceding with the default configuration${NC} \n"
  fi

  echo -e "\n${PURPLE}Lets install the dependencies üì¶ ${NC} \n"
  dependencies_install 
  echo -e "\n${GREEN}Dependencies installed${NC} \n"

  echo -e "\n${PURPLE}Copying configuration files... ‚öôÔ∏è ${NC} \n"
  make setup-conf

  read -n1 -p 'Shall we install for development or production ? (type "d" or "p"): '
  if [[ "${REPLY}" == 'd' ]]; then
    make start
  else
    docker-compose pull
  fi

  echo -e "\n${GREEN}Installation complete üéâ ${NC} \n"
  # msg "backend-services/configs"
}

# :command.usage
artemis_usage() {
  if [[ -n $long_usage ]]; then
    printf "artemis - ARTEMIS installer script\n"
    echo

  else
    printf "artemis - ARTEMIS installer script\n"
    echo

  fi

  printf "Usage:\n"
  printf "  artemis ACTION [options]\n"
  printf "  artemis --help | -h\n"
  printf "  artemis --version | -v\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --build, -b"
    printf "    Build the images from the Dockerfiles\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  ACTION"
    printf "    the action to perform\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  artemis install\n"
    printf "  artemis install -b\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    if [[ "${args[action]}" == "install" ]]; then
      install
    fi
    # for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  echo 

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    artemis_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="root"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --build | -b )
      args[--build]=1
      shift
      ;;

    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[action]+x} ]]; then
        # :argument.validations
        args[action]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[action]+x} ]]; then
    printf "missing required argument: ACTION\nusage: artemis ACTION [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  echo """
     ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ   ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ   ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ 
    ‚ñà       ‚ñà   ‚ñÑ  ‚ñà ‚ñà       ‚ñà       ‚ñà  ‚ñà‚ñÑ‚ñà  ‚ñà   ‚ñà       ‚ñà
    ‚ñà   ‚ñÑ   ‚ñà  ‚ñà ‚ñà ‚ñà ‚ñà‚ñÑ     ‚ñÑ‚ñà    ‚ñÑ‚ñÑ‚ñÑ‚ñà       ‚ñà   ‚ñà  ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà
    ‚ñà  ‚ñà‚ñÑ‚ñà  ‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñà‚ñÑ  ‚ñà   ‚ñà ‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà       ‚ñà   ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ 
    ‚ñà       ‚ñà    ‚ñÑ‚ñÑ  ‚ñà ‚ñà   ‚ñà ‚ñà    ‚ñÑ‚ñÑ‚ñÑ‚ñà       ‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ  ‚ñà
    ‚ñà   ‚ñÑ   ‚ñà   ‚ñà  ‚ñà ‚ñà ‚ñà   ‚ñà ‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà ‚ñà‚ñà‚ñÑ‚ñà‚ñà ‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà ‚ñà
    ‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà  ‚ñà‚ñÑ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñÑ‚ñà   ‚ñà‚ñÑ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà
    
""";

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
